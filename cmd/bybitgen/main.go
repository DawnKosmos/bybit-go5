package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// Code generator that scans Bybit docs Markdown under docsRoot and emits:
// - models/<folder>.go with Request/Response placeholders per endpoint
// - client_<folder>.go with Client methods calling c.GET/c.POST
// Detailed parsing and generation live in other files in this package.

func cleanupClientFiles(rootDir string, validFolders []string) error {
	// Build set of valid target filenames
	valid := make(map[string]struct{}, len(validFolders))
	for _, f := range validFolders {
		valid[fmt.Sprintf("client_%s.go", f)] = struct{}{}
	}
	entries, err := os.ReadDir(rootDir)
	if err != nil {
		return err
	}
	const marker = "// Code generated by bybitgen; DO NOT EDIT."
	for _, e := range entries {
		name := e.Name()
		if e.IsDir() || !strings.HasPrefix(name, "client_") || !strings.HasSuffix(name, ".go") {
			continue
		}
		if _, ok := valid[name]; ok {
			continue
		}
		// Only delete files that contain our generated marker
		path := filepath.Join(rootDir, name)
		b, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		if strings.HasPrefix(string(b), marker) {
			if err := os.Remove(path); err != nil {
				return err
			}
		}
	}
	return nil
}

// cleanupModelsFiles removes stale generated REST model files (models/<folder>.go)
// and leaves any manually maintained or WS-specific files intact.
func cleanupModelsFiles(modelsDir string, validFolders []string) error {
	valid := make(map[string]struct{}, len(validFolders))
	for _, f := range validFolders {
		valid[fmt.Sprintf("%s.go", f)] = struct{}{}
	}
	entries, err := os.ReadDir(modelsDir)
	if err != nil {
		return err
	}
	const marker = "// Code generated by bybitgen; DO NOT EDIT."
	for _, e := range entries {
		name := e.Name()
		if e.IsDir() || !strings.HasSuffix(name, ".go") {
			continue
		}
		// Only consider files following our REST pattern <folder>.go
		// Skip known non-REST generated files
		if strings.HasPrefix(name, "ws_") || name == "ws_latest.go" || strings.HasPrefix(name, "zbase_") {
			continue
		}
		if _, ok := valid[name]; ok {
			continue
		}
		path := filepath.Join(modelsDir, name)
		b, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		if strings.HasPrefix(string(b), marker) {
			if err := os.Remove(path); err != nil {
				return err
			}
		}
	}
	return nil
}

func main() {
	docsRoot := flag.String("docs-root", "libs/bybit-docs/docs/v5", "Root of Bybit docs v5")
	outModels := flag.String("out-models", "models", "Output directory for models")
	outClient := flag.String("out-client", ".", "Output directory for client files (repo root)")
	flag.Parse()

	// Ensure models directory exists and write/update base result types.
	if err := os.MkdirAll(*outModels, 0o755); err != nil {
		fatalf("create models dir: %v", err)
	}
	if err := writeModelsBase(*outModels); err != nil {
		fatalf("write models base: %v", err)
	}

	folders, err := readFolders(*docsRoot)
	if err != nil {
		fatalf("scan docs root: %v", err)
	}

	all := map[string][]Endpoint{}
	for _, folder := range folders {
		endpoints, err := scanEndpoints(filepath.Join(*docsRoot, folder))
		if err != nil {
			fatalf("scan endpoints for %s: %v", folder, err)
		}
		if len(endpoints) == 0 {
			continue
		}
		for i := range endpoints {
			endpoints[i].Folder = folder
			endpoints[i].Name = makeName(endpoints[i].Method, endpoints[i].Path)
		}
		all[folder] = endpoints
	}

	// Cleanup stale generated client files (e.g., client_abandon.go)
	if err := cleanupClientFiles(*outClient, folders); err != nil {
		fatalf("cleanup client files: %v", err)
	}
	// Cleanup stale generated REST models (e.g., abandon.go), while preserving WS files and manual files.
	if err := cleanupModelsFiles(*outModels, folders); err != nil {
		fatalf("cleanup models files: %v", err)
	}

	// Generate per-folder files
	for folder, eps := range all {
		sort.Slice(eps, func(i, j int) bool { return eps[i].Name < eps[j].Name })
		if err := writeModelsFile(*outModels, folder, eps); err != nil {
			fatalf("write models for %s: %v", folder, err)
		}
		if err := writeClientFile(*outClient, folder, eps); err != nil {
			fatalf("write client for %s: %v", folder, err)
		}
	}

	// Generate WS artifacts (seed V5 models and latest aliases). This is a separate pipeline from REST.
	if err := generateWSArtifacts(*outModels); err != nil {
		fatalf("generate ws artifacts: %v", err)
	}
}

func fatalf(format string, a ...any) {
	fmt.Fprintf(os.Stderr, format+"\n", a...)
	os.Exit(1)
}

func readFolders(root string) ([]string, error) {
	entries, err := os.ReadDir(root)
	if err != nil {
		return nil, err
	}
	var out []string
	for _, e := range entries {
		if !e.IsDir() || strings.HasPrefix(e.Name(), ".") {
			continue
		}
		// Skip abandoned docs folder and websocket (handled separately)
		if e.Name() == "abandon" || e.Name() == "websocket" {
			continue
		}
		out = append(out, e.Name())
	}
	sort.Strings(out)
	return out, nil
}
