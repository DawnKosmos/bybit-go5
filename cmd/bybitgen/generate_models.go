package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func writeModelsFile(modelsDir, folder string, eps []Endpoint) error {
	var b strings.Builder
	b.WriteString("// Code generated by bybitgen; DO NOT EDIT.\n")
	b.WriteString("package models\n\n")
	// Helpers for response generation
	// toExportedResp converts response field names (which may contain indexes like
	// "list[0]: startTime") into valid Go identifiers (e.g., "StartTime").
	toExportedResp := func(name string) string {
		n := strings.TrimSpace(name)
		if idx := strings.Index(n, ":"); idx >= 0 {
			n = strings.TrimSpace(n[idx+1:])
		}
		// strip brackets and colons remnants
		n = strings.ReplaceAll(n, "[", " ")
		n = strings.ReplaceAll(n, "]", " ")
		n = strings.ReplaceAll(n, ":", " ")
		return toExported(n)
	}
	// isIndexedList returns true if docs describe an array element by indexed columns
	// such as "list[0]: ...", implying the actual payload is [][], not []object.
	isIndexedList := func(params []Param) bool {
		for _, p := range params {
			n := strings.TrimSpace(p.Name)
			ln := strings.ToLower(n)
			if strings.HasPrefix(ln, "list[") || strings.Contains(n, "]:") {
				return true
			}
		}
		return false
	}
	// redefine with closure to allow recursion
	var writeNested func(b *strings.Builder, ep Endpoint, nestedKey string, params []Param, indent string)
	writeNested = func(b *strings.Builder, ep Endpoint, nestedKey string, params []Param, indent string) {
		for _, np := range params {
			nf := toExportedResp(np.Name)
			t := strings.ToLower(strings.TrimSpace(np.Type))
			switch t {
			case "array":
				inner := ep.RespNested[nestedKey+"."+np.Name]
				if len(inner) == 0 {
					if np.Comment != "" {
						b.WriteString(fmt.Sprintf("%s%s []string `json:\"%s\"` // %s\n", indent, nf, np.Name, cleanComment(np.Comment)))
					} else {
						b.WriteString(fmt.Sprintf("%s%s []string `json:\"%s\"`\n", indent, nf, np.Name))
					}
				} else {
					if isIndexedList(inner) {
						// Array-of-arrays case
						b.WriteString(fmt.Sprintf("%s%s [][]string `json:\"%s\"`\n", indent, nf, np.Name))
					} else {
						b.WriteString(fmt.Sprintf("%s%s []struct {\n", indent, nf))
						writeNested(b, ep, nestedKey+"."+np.Name, inner, indent+"\t")
						b.WriteString(fmt.Sprintf("%s} `json:\"%s\"`\n", indent, np.Name))
					}
				}
			case "object":
				inner := ep.RespNested[nestedKey+"."+np.Name]
				if len(inner) == 0 {
					if np.Comment != "" {
						b.WriteString(fmt.Sprintf("%s%s string `json:\"%s\"` // %s\n", indent, nf, np.Name, cleanComment(np.Comment)))
					} else {
						b.WriteString(fmt.Sprintf("%s%s string `json:\"%s\"`\n", indent, nf, np.Name))
					}
				} else {
					b.WriteString(fmt.Sprintf("%s%s struct {\n", indent, nf))
					writeNested(b, ep, nestedKey+"."+np.Name, inner, indent+"\t")
					b.WriteString(fmt.Sprintf("%s} `json:\"%s\"`\n", indent, np.Name))
				}
			default:
				gt := respMapType(np.Type)
				if np.Comment != "" {
					b.WriteString(fmt.Sprintf("%s%s %s `json:\"%s\"` // %s\n", indent, nf, gt, np.Name, cleanComment(np.Comment)))
				} else {
					b.WriteString(fmt.Sprintf("%s%s %s `json:\"%s\"`\n", indent, nf, gt, np.Name))
				}
			}
		}
	}
	for _, ep := range eps {
		b.WriteString(fmt.Sprintf("// %s %s\n", ep.Method, ep.Path))
		b.WriteString(fmt.Sprintf("type %sRequest struct {\n", ep.Name))
		for _, p := range ep.Params {
			goType := mapType(p.Type)
			field := toExported(p.Name)
			tagName := "json"
			if ep.Method == "GET" {
				tagName = "url"
			}

			tag := fmt.Sprintf("%s:\"%s\"", tagName, p.Name)
			if !p.Required {
				tag = fmt.Sprintf("%s:\"%s,omitempty\"", tagName, p.Name)
			}
			// comment on field
			if p.Comment != "" {
				b.WriteString(fmt.Sprintf("\t%s %s `%s` // %s\n", field, goType, tag, cleanComment(p.Comment)))
			} else {
				b.WriteString(fmt.Sprintf("\t%s %s `%s`\n", field, goType, tag))
			}
		}
		b.WriteString("}\n\n")
		// Response
		if len(ep.RespTop) == 0 {
			b.WriteString(fmt.Sprintf("type %sResponse struct {\n\t// TODO: fill in response fields parsed from docs\n}\n\n", ep.Name))
		} else {
			b.WriteString(fmt.Sprintf("type %sResponse struct {\n", ep.Name))
			for _, rp := range ep.RespTop {
				field := toExported(rp.Name)
				// Determine Go type for response field
				lowerType := strings.ToLower(strings.TrimSpace(rp.Type))
				switch lowerType {
				case "array":
					nested := ep.RespNested[rp.Name]
					if len(nested) == 0 {
						// default to []string when item schema unknown
						b.WriteString(fmt.Sprintf("\t%s []string `json:\"%s\"`\n", field, rp.Name))
					} else {
						if isIndexedList(nested) {
							b.WriteString(fmt.Sprintf("\t%s [][]string `json:\"%s\"`\n", field, rp.Name))
						} else {
							b.WriteString(fmt.Sprintf("\t%s []struct {\n", field))
							// write nested fields, supporting deeper levels using key rp.Name
							writeNested(&b, ep, rp.Name, nested, "\t\t")
							b.WriteString(fmt.Sprintf("\t} `json:\"%s\"`\n", rp.Name))
						}
					}
				case "object":
					nested := ep.RespNested[rp.Name]
					if len(nested) == 0 {
						// unknown object -> string fallback
						b.WriteString(fmt.Sprintf("\t%s string `json:\"%s\"`\n", field, rp.Name))
					} else {
						b.WriteString(fmt.Sprintf("\t%s struct {\n", field))
						writeNested(&b, ep, rp.Name, nested, "\t\t")
						b.WriteString(fmt.Sprintf("\t} `json:\"%s\"`\n", rp.Name))
					}
				default:
					gt := respMapType(rp.Type)
					if rp.Comment != "" {
						b.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"` // %s\n", field, gt, rp.Name, cleanComment(rp.Comment)))
					} else {
						b.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", field, gt, rp.Name))
					}
				}
			}
			b.WriteString("}\n\n")
		}
	}
	file := filepath.Join(modelsDir, fmt.Sprintf("%s.go", folder))
	return os.WriteFile(file, []byte(b.String()), 0o644)
}

func writeModelsBase(modelsDir string) error {
	const base = `// Code generated by bybitgen; DO NOT EDIT.
package models

type ReturnCode interface {
	Return() (code int, msg string)
}

type Response[T any] struct {
	RetCode int    ` + "`json:\"retCode\"`" + `
	RetMsg  string ` + "`json:\"retMsg\"`" + `
	Result  T      ` + "`json:\"result\"`" + `
	Time    int64  ` + "`json:\"time\"`" + `
}

func (r *Response[T]) Return() (code int, msg string) {
	return r.RetCode, r.RetMsg
}

type ResponseBatch[T any] struct {
	RetCode    int    ` + "`json:\"retCode\"`" + `
	RetMsg     string ` + "`json:\"retMsg\"`" + `
	Result     T      ` + "`json:\"result\"`" + `
	RetExtInfo struct {
		List []struct {
			Code int    ` + "`json:\"code\"`" + `
			Msg  string ` + "`json:\"msg\"`" + `
		} ` + "`json:\"list\"`" + `
	} ` + "`json:\"retExtInfo\"`" + `
	Time int64 ` + "`json:\"time\"`" + `
}

func (r *ResponseBatch[T]) Return() (code int, msg string) {
	msg = r.RetMsg
	for _, v := range r.RetExtInfo.List {
		msg += "|" + v.Msg
	}
	return r.RetCode, msg
}
`
	return os.WriteFile(filepath.Join(modelsDir, "zbase_result.go"), []byte(base), 0o644)
}

// respMapType maps response types from docs to Go types.
// Arrays/objects are handled by the caller with anonymous structs; here we map scalar-like and fallback types.
func respMapType(t string) string {
    tt := strings.ToLower(strings.TrimSpace(t))
    switch tt {
    case "string", "text":
        return "string"
    case "integer", "int", "int32", "int64", "long", "timestamp(ms)", "timestamp":
        return "int64"
    case "boolean", "bool":
        return "bool"
    case "number", "float", "double", "decimal":
        // keep as string to avoid precision/decimal issues from docs
        return "string"
    case "array":
        return "[]string"
    case "object":
        return "string"
    default:
        return "string"
    }
}
